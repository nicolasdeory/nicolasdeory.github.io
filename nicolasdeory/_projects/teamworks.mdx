---
title: Teamworks
description: A functional proof-of-concept app focused on team management, fine-grained permissions, and streamlined messaging.
githubUrl: https://github.com/nicolasdeory/teamworks
---
![Teamworks messaging view](/projects/teamworks2.png)

Teamworks was a group project made for a Design and Testing class in the University of Seville.
This project was focused on implementing a basic team management system, as well as a messaging system between different teams.

The idea was to create a system that would allow teams to easily communicate with each other, and to keep track of the
projects, milestones and tasks they were working on. Implementing features with real utility was a priority, even when the main goal
was to design a maintainable architecture as well as implementing tests that cover as much of the codebase as possible.

The backend was implemented in **Java**, following an MVC architecture using **Spring Boot**. The web app was built with **React**, with no additional frameworks,
in an effort to thoroughly learn best practices and the functional component paradigm before introducing abstractions such as Next.js or UI frameworks such as Chakra.

The priority when building the frontend was to keep components as modular as possible, applying composition whenever possible so the team could easily reuse and maintain
components.

Lastly, we paid attention to UI/UX design, as we believed it was important to create an SPA that was potentially powerful, while also easy to use and understand. 

## Implementing roles with granular permissions

![Teamworks milestone management view](/projects/teamworks1.png)

The app has several user roles, namely, team managers, department managers, project managers and regular users.
Each of these has management privileges over several areas of the team. The roles follow a hierarchy, with the team manager having access to everything,
and a department manager having access to everything in the department, including projects, and so on.

This permission system was challenging to implement with the built-in Spring Security framework provided by Spring Boot.
Therefore, we decided to authenticate requests using Spring Interceptors, which allowed for much greater flexibility.